* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    background: #f2f2f2;
    display: flex;
    justify-content: center;
}


/* 2 FORMAS DE COMO CREAR COMPONENTES RESPONSIVE */

/* FORMA 1 */
.contenedor {
    width: 90%;          /* Le digo al navegador que ocupe el 90% del ancho del body (o del contenedor que lo rodee)  */
    max-width: 500px;    /* Pero nunca quiero que supere los 500px, aunque el 90% sea m√°s grande. */
    margin: 40px 0;      



    .card {
        background: white;
        box-shadow: 2px 2px 20px rgba(0, 0, 0, 0.2); /* Aplico una sombra: 
                                                                   - 2px a la derecha (horizontal) 
                                                                   - 2px hacia abajo (vertical) 
                                                                   - 20px de difuminado 
                                                                   - color negro con 20% de opacidad, para que se vea suave. */
        border-radius: 5px;

        overflow: hidden; /* Corto cualquier contenido que se salga del borde de la tarjeta, √∫til si hay im√°genes o elementos que podr√≠an desbordar. 
        Si la imagen es m√°s grande que la tarjeta:

                    Con overflow: hidden ‚Üí la parte que se sale se oculta, y la tarjeta mantiene su forma limpia.
                    Resumen simple: corta cualquier cosa que se salga del borde de la tarjeta para que todo se vea ordenado.
                    
                    Cu√°ndo se usa: cuando quieres mantener los bordes limpios, por ejemplo, en tarjetas con im√°genes, 
                    contenedores con bordes redondeados (border-radius), o cajas donde el contenido no deber√≠a desbordarse.*/

        img {
            width: 100%; /* La imagen ocupa todo el ancho del contenedor padre, .card */
            max-height: 250px;  /* La imagen nunca ser√° m√°s alta de 250px. */
        }

        .textos {
            padding: 20px;

            h3 {
                font-size: 30px;
                margin-bottom: 20px;
            }

            p {
                font-size: 20px;
                margin-bottom: 10px;
            }

            a {
                background: black;
                color: white;
                text-decoration: none;
                display: inline-block;  /* Permite aplicar padding y tama√±o como si fuera un bloque, pero sigue en l√≠nea. */
                padding: 10px 30px;
                font-size: 20px;
                border-radius: 5px;
            }
        }

        /*  media query: le dice al navegador "aplica estas reglas solo si se cumple esta condici√≥n" */
        @media screen and (max-width: 500px) {
            & { /*  & ‚Üí el selector padre m√°s cercano (el que envuelve este bloque)  .card  */
                .textos { /* dentro de .textos aplica estos estilos: */
                    padding: 10px;

                    h3 { /* dentro de .textos seleciona el h3 */
                        font-size: 20px;
                        margin-bottom: 5px;
                    }
                    
                    p { /* dentro de .textos seleciona el p */
                        font-size: 14px;
                        margin-bottom: 10px;
                    }

                    a { /* dentro de .textos seleciona el a */
                        padding: 5px 15px;
                        font-size: 12px;
                    }
                }
            }
        }
    }
}


/* FORMA 2 */
.contenedor {
    width: 90%;          
    max-width: 500px;    
    margin: 40px 0;      

    .card {
        background: white;
        box-shadow: 2px 2px 20px rgba(0, 0, 0, 0.2); 
        border-radius: 5px;
        overflow: hidden; 
        font-size: 16px;     /* Explicaci√≥n clara sobre em:

       - 1em se basa en el font-size del contenedor padre inmediato.
       - h3 est√° dentro de .textos, pero .textos NO tiene font-size declarado.
       - Por eso, h3 hereda el font-size del siguiente contenedor padre que s√≠ tenga valor, en este caso .card.
       - .card tiene font-size: 16px, por lo que 1em = 16px aqu√≠.
       - Entonces: 1.875em √ó 16px = 30px
       
       üîπ Regla general: 
         Si el padre no tiene font-size, em sube un nivel hasta encontrar un valor.
         Por defecto, el body tiene 16px.
       üîπ Cuando cambiamos el font-size del padre (por ejemplo en media query), todos los em de los hijos se recalculan autom√°ticamente.*/
        

        img {
            width: 100%; 
            max-height: 15.62em; /* 250px */ 
        }

        .textos {
            padding: 1.25em; /* 20px */

            h3 {
                font-size: 1.875em; /* 1em hace referencia al FONT-SIZE del contenedor padre. En este caso seria de .textos pero .textos no tiene un 
                       FONT-SIZE declarado va a buscar al siguiente contenedor padre en este caso .card  (ahora el h3 tendra el tama√±o del font-size de .card [1em = 16px]) */
                margin-bottom: 0.625em; /* 10px */
            }

            p {
                font-size: 1.25em; /* 20px */
                margin-bottom: 1.25em; /* 20px */
            }

            a {
                background: black;
                color: white;
                text-decoration: none;
                display: inline-block;  
                padding: 0.625em 1.875em;  /* 10px 30px */
                font-size: 1.25em; /* 20px */
                border-radius: 0.315em; /* 5px */
            }
        }

      
        @media screen and (max-width: 500px) { 
            & { /* Representa el selector actual donde est√°s escribiendo. No apunta al ‚Äúpadre‚Äù, sino al mismo selector que est√°s anidando ( .card )*/
                font-size: 10px;
                /* Cuando cambiamos el font-size del contenedor padre (.card), todos los elementos hijos que usan em se recalculan autom√°ticamente seg√∫n este nuevo tama√±o.*/
            }
    }
  }
}
